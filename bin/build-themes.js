#!/usr/bin/env node
import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { createRequire } from 'node:module';

const __filename = fileURLToPath(import.meta.url);
const require = createRequire(import.meta.url);
const CWD = process.cwd();

// --- Configuration Helpers ---

function getConfigPath() {
    // We expect execution via: node build-themes.js --config=/path/to/config.json
    const configArg = process.argv.find(arg => arg.startsWith('--config='));
    if (!configArg) {
        console.error('Error: No --config argument provided.');
        process.exit(1);
    }
    return configArg.split('=')[1];
}

async function importShiki() {
    try {
        // 1. Try resolving from local node_modules (Standard Node/Bun/PNPM)
        const shikiPath = require.resolve('shiki', { paths: [CWD] });
        return await import(shikiPath);
    } catch (e) {
        try {
            // 2. Deno fallback (npm: specifier)
            return await import('npm:shiki');
        } catch (e2) {
            console.error('Error: Could not resolve "shiki". Ensure it is installed in your project.');
            process.exit(1);
        }
    }
}

// --- Logic ---

const STANDARD_PALETTE_SCOPES = {
    'comment': ['comment', 'punctuation.definition.comment'],
    'string': ['string', 'punctuation.definition.string'],
    'keyword': ['keyword', 'storage.type', 'storage.modifier'],
    'function': ['entity.name.function', 'support.function'],
    'class': ['entity.name.type', 'entity.name.class', 'support.class'],
    'constant': ['constant', 'support.constant'],
    'punctuation': ['punctuation'],
    'variable': ['variable', 'entity.name.variable'],
};

function resolveColorForScopes(themeSettings, targetScopes) {
    for (const targetScope of targetScopes) {
        for (const rule of themeSettings) {
             if (!rule.scope || !rule.settings.foreground) continue;
             const ruleScopes = Array.isArray(rule.scope) ? rule.scope : [rule.scope];
             if (ruleScopes.some(s => s.startsWith(targetScope))) {
                 return rule.settings.foreground;
             }
        }
    }
    return null;
}

async function build() {
    const configPath = getConfigPath();
    const configContent = fs.readFileSync(configPath, 'utf8');
    const config = JSON.parse(configContent);

    const shiki = await importShiki();
    const themeNames = [...new Set(Object.values(config.themes))];

    // Create Highlighter
    const highlighter = await shiki.createHighlighter({
        themes: themeNames,
        langs: ['javascript'], // minimal lang requirement
    });

    let cssOutput = ["/** Auto-generated by Laravel Shiki Bridge **/"];

    for (const [themeKey, themeName] of Object.entries(config.themes)) {
        const theme = highlighter.getTheme(themeName);

        // CSS Selector logic
        let selector = ':root';
        if (themeKey === 'dark') selector = '.dark';

        cssOutput.push(`\n/* Theme: ${themeName} (${themeKey}) */`);
        cssOutput.push(`${selector} {`);

        // Workbench colors
        const editorBg = theme.bg;
        const editorFg = theme.fg;

        cssOutput.push(`  --${config.var_prefix}-bg: ${editorBg};`);
        cssOutput.push(`  --${config.var_prefix}-fg: ${editorFg};`);

        // Token extraction
        const themeSettings = theme.settings || theme.tokenColors || [];

        for (const [tokenName, possibleScopes] of Object.entries(STANDARD_PALETTE_SCOPES)) {
            let color = resolveColorForScopes(themeSettings, possibleScopes);
            if (!color) color = editorFg; // Fallback
            cssOutput.push(`  --${config.var_prefix}-token-${tokenName}: ${color};`);
        }
        cssOutput.push(`}`);
    }

    // Write File
    const outputPath = path.resolve(CWD, config.output);
    const outputDir = path.dirname(outputPath);
    if (!fs.existsSync(outputDir)){
        fs.mkdirSync(outputDir, { recursive: true });
    }

    fs.writeFileSync(outputPath, cssOutput.join('\n'));
    console.log(`CSS written to: ${config.output}`);
}

build().catch(err => {
    console.error(err);
    process.exit(1);
});
